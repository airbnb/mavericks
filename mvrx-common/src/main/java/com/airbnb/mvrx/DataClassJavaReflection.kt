package com.airbnb.mvrx

import java.lang.reflect.Method
import java.lang.reflect.Modifier
import kotlin.math.ceil

/**
 * Java reflection utilities for working with Kotlin data classes.
 *
 * These utilities avoid using Kotlin reflection APIs that read metadata (like KClass.isData,
 * KClass.memberProperties, KFunction.callBy) because they can fail in environments with
 * incompatible kotlin-reflect versions.
 */

/**
 * Since we can only use java reflection, this basically duck types a data class.
 * componentN methods are also used for @PersistState.
 *
 * This avoids using KClass.isData which requires reading Kotlin metadata and can fail
 * in environments with incompatible kotlin-reflect versions (e.g., Android Studio's
 * layoutlib with Kotlin 2.3+).
 */
@InternalMavericksApi
val Class<*>.isData: Boolean
    get() {
        // When a value class is present in the constructor, Kotlin mangles the copy method name
        // to avoid signature clashes (e.g., "copy-KtkBMb8$default" instead of "copy$default").
        // We check for either the exact name "copy$default" or the pattern "copy-*$default".
        val hasCopyDefault = declaredMethods.any { method ->
            method.isSynthetic && method.name.let { name ->
                name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
            }
        }
        if (!hasCopyDefault) return false

        // Similarly, component1 can be mangled when it's a value class type.
        // It can also have module names appended for internal properties.
        // Patterns: "component1", "component1$module", "component1-<hash>"
        val hasComponent1 = declaredMethods.any { method ->
            method.name.let { name ->
                name == "component1" ||
                    name.startsWith("component1\$") ||
                    name.startsWith("component1-")
            }
        }
        if (!hasComponent1) return false

        declaredMethods.firstOrNull { it.name == "equals" } ?: return false
        declaredMethods.firstOrNull { it.name == "hashCode" } ?: return false
        return true
    }

/**
 * Calls the copy() method on a Kotlin data class instance using Java reflection.
 *
 * This uses the synthetic copy$default method generated by the Kotlin compiler,
 * which handles default parameter values. This avoids using KFunction.callBy()
 * which requires Kotlin reflection metadata and can fail in environments with
 * incompatible kotlin-reflect versions.
 *
 * @param params Map of parameter names to their new values. Parameters not
 *               specified will retain their current values from this instance.
 * @return A new instance with the specified parameters changed.
 */
@InternalMavericksApi
@Suppress("UNCHECKED_CAST")
fun <T : Any> callCopy(targetObject: T, vararg params: Pair<String, Any?>): T {
    val jvmClass = targetObject::class.java
    val paramMap = params.toMap()

    // Find copy$default - the synthetic method that handles default parameters
    // When a value class is present, the method name may be mangled (e.g., "copy-KtkBMb8$default")
    val copyFunction = jvmClass.declaredMethods.first { method ->
        method.isSynthetic && method.name.let { name ->
            name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
        }
    }

    // For data classes, Kotlin generates a static function called copy$default.
    // The first parameter is the object to copy from.
    // The next parameters are all of parameters to copy (it's jvm bytecode/java so there are no optional parameters in the generated method).
    // The next parameter(s) are a bitmask. Each parameter index corresponds to one bit in the int.
    //     If the bitmask is 1 for a given parameter then the new object will have the original object's value and the parameter value will be ignored.
    //     If the bitmask is 0 then it will use the value from the parameter.
    //     There is 1 bitmask for every 32 parameters. If there are 48 parameters, there will be 2 bitmasks. Parameter 33 will be the first bit of the 2nd bitmask.
    // The last parameter is ignored. It can be null.

    // We need to know how many parameters go to the copy function in order to invoke it.
    // Note that this is not the same as the number of parameters in the constructor.
    // The constructor can contain a "DefaultConstructorMarker" in some cases, such as if a value class type is present in the constructor,
    // and in this case the number of parameters of the constructor is greater than the number of parameters in the copy function.
    // For accuracy in all cases we use the copy function to determine the number of parameters.
    val paramCount = calculateParameterCountOfCopyFunction(copyFunction)

    // Build a mapping from property names to constructor parameter indices.
    // We use componentN methods to determine the correct order, since declaredFields
    // order is not guaranteed by the JVM and can be changed by R8/ProGuard.
    val propertyIndexMap = buildPropertyIndexMap(jvmClass, targetObject)

    // There is 1 bitmask for each block of 32 parameters.
    val parameterBitMasks = IntArray(ceil(paramCount / 32.0).toInt())
    val parameters = arrayOfNulls<Any?>(paramCount)

    // Initialize all parameters to use default values (bitmask = 1 means use original value)
    for (i in 0 until paramCount) {
        parameterBitMasks[i / 32] = parameterBitMasks[i / 32] or (1 shl (i % 32))
        // These parameters will be ignored. We just need to put in something of the correct type to match the method signature.
        // 1 is added to account for the first parameter, which is the object to copy from (ie, the original instance).
        parameters[i] = copyFunction.parameterTypes[i + 1].defaultParameterValue
    }

    // Set the parameters we want to change
    for ((propName, newValue) in paramMap) {
        val index = propertyIndexMap[propName]
            ?: error("Could not find constructor parameter index for property '$propName' on ${jvmClass.simpleName}")
        parameters[index] = newValue
        // Clear the bitmask for this parameter so the new value is used instead of the original
        parameterBitMasks[index / 32] = parameterBitMasks[index / 32] and (1 shl (index % 32)).inv()
    }

    // See the comment above for information on the parameters here.
    copyFunction.isAccessible = true
    return copyFunction.invoke(
        null, // Indicates the object to invoke on. This is null for a static method.
        targetObject,
        *parameters,
        *parameterBitMasks.toTypedArray(),
        null
    ) as T
}

/**
 * Builds a mapping from property names to their constructor parameter index.
 *
 * Uses two strategies:
 * 1. Primary: Parse toString() to get parameter names in constructor order. Data classes
 *    auto-generate toString() as "ClassName(p1=v1, p2=v2, ...)" which directly gives names
 *    in order without value-matching ambiguity.
 * 2. Fallback: Match componentN methods to fields by type and value, using a mutation-probe
 *    technique to resolve cases where multiple fields share the same type and value.
 *
 * The primary strategy avoids issues where R8/ProGuard reorders fields and body properties
 * (non-constructor properties with backing fields) can collide with constructor parameters
 * when they share the same type and runtime value.
 */
private fun <T : Any> buildPropertyIndexMap(jvmClass: Class<*>, instance: T): Map<String, Int> {
    val componentRegex = Regex("""component(\d+).*""")
    val componentMethods = jvmClass.declaredMethods
        .mapNotNull { method ->
            if (method.parameterCount != 0) return@mapNotNull null
            val match = componentRegex.matchEntire(method.name) ?: return@mapNotNull null
            val n = match.groupValues[1].toIntOrNull() ?: return@mapNotNull null
            n to method
        }
        .sortedBy { it.first }

    val fields = jvmClass.declaredFields
        .filter { !Modifier.isStatic(it.modifiers) && !it.isSynthetic }

    val fieldNames = fields.map { it.name }.toSet()

    // Strategy 1: Parse toString() for direct name-to-index mapping.
    // The Kotlin compiler generates toString() with constructor parameter names as string
    // literals in declaration order. These names survive R8 field reordering since they're
    // embedded as constants in the bytecode.
    val toStringNames = parseDataClassConstructorParamNames(instance.toString())
    if (toStringNames != null && toStringNames.size == componentMethods.size) {
        if (toStringNames.all { it in fieldNames }) {
            return toStringNames.mapIndexed { index, name -> name to index }.toMap()
        }
    }

    // Strategy 2: ComponentN + value matching with mutation-probe disambiguation.
    val result = mutableMapOf<String, Int>()
    val usedFields = mutableSetOf<String>()

    for ((n, componentMethod) in componentMethods) {
        val index = n - 1
        componentMethod.isAccessible = true
        val componentValue = componentMethod.invoke(instance)

        val candidates = fields.filter { field ->
            if (field.name in usedFields) return@filter false
            if (field.type != componentMethod.returnType) return@filter false
            field.isAccessible = true
            field.get(instance) == componentValue
        }

        when {
            candidates.size == 1 -> {
                result[candidates[0].name] = index
                usedFields.add(candidates[0].name)
            }
            candidates.size > 1 -> {
                // Ambiguous: temporarily change each candidate's value to identify which
                // field actually backs the componentN method.
                var matched = false
                for (field in candidates) {
                    field.isAccessible = true
                    val originalValue = field.get(instance)
                    val probeValue = getProbeValue(field.type, originalValue) ?: continue
                    try {
                        field.set(instance, probeValue)
                        val probeResult = componentMethod.invoke(instance)
                        field.set(instance, originalValue)
                        if (probeResult != componentValue) {
                            result[field.name] = index
                            usedFields.add(field.name)
                            matched = true
                            break
                        }
                    } catch (_: Exception) {
                        try { field.set(instance, originalValue) } catch (_: Exception) {}
                    }
                }
                if (!matched) {
                    result[candidates[0].name] = index
                    usedFields.add(candidates[0].name)
                }
            }
        }
    }

    return result
}

/**
 * Returns a value different from [currentValue] for the given primitive type, used as a
 * probe to test which field backs a componentN method. Returns null for reference types
 * where a safe probe value can't be determined.
 */
private fun getProbeValue(type: Class<*>, currentValue: Any?): Any? {
    return when (type) {
        java.lang.Boolean.TYPE -> !(currentValue as Boolean)
        Integer.TYPE -> (currentValue as Int) + 1
        java.lang.Long.TYPE -> (currentValue as Long) + 1L
        java.lang.Float.TYPE -> (currentValue as Float) + 1f
        java.lang.Double.TYPE -> (currentValue as Double) + 1.0
        java.lang.Short.TYPE -> ((currentValue as Short) + 1).toShort()
        java.lang.Byte.TYPE -> ((currentValue as Byte) + 1).toByte()
        Character.TYPE -> (currentValue as Char) + 1
        else -> if (currentValue != null) null else return null
    }
}

/**
 * Parses constructor parameter names from a data class's toString() output.
 *
 * Kotlin data classes generate toString() as: `ClassName(param1=val1, param2=val2, ...)`
 * with parameter names as string literals in constructor declaration order. We extract just
 * the names (the identifiers before each `=`), tracking bracket depth to skip over values
 * that may contain commas or equals signs.
 *
 * @return Parameter names in constructor order, or null if the format doesn't match.
 */
private fun parseDataClassConstructorParamNames(toStringOutput: String): List<String>? {
    val openParen = toStringOutput.indexOf('(')
    if (openParen == -1 || !toStringOutput.endsWith(")")) return null

    val names = mutableListOf<String>()
    var i = openParen + 1
    val end = toStringOutput.length - 1

    while (i < end) {
        while (i < end && toStringOutput[i] == ' ') i++
        if (i >= end) break

        val nameStart = i
        while (i < end && toStringOutput[i] != '=') i++
        if (i >= end) return null

        val name = toStringOutput.substring(nameStart, i)
        if (!isValidKotlinIdentifier(name)) return null
        names.add(name)
        i++ // skip '='

        // Skip the value, tracking nested brackets/parens
        var depth = 0
        while (i < end) {
            when (toStringOutput[i]) {
                '(', '[', '{' -> depth++
                ')', ']', '}' -> depth--
                ',' -> if (depth == 0) {
                    i++
                    if (i < end && toStringOutput[i] == ' ') i++
                    break
                }
            }
            i++
        }
    }

    return names.ifEmpty { null }
}

private fun isValidKotlinIdentifier(name: String): Boolean {
    if (name.isEmpty()) return false
    if (!name[0].isLetter() && name[0] != '_') return false
    return name.all { it.isLetterOrDigit() || it == '_' }
}

/**
 * Calculates the number of data class properties from the copy$default function.
 * This is more accurate than counting constructor parameters because value classes
 * can cause additional synthetic parameters in the constructor.
 */
internal fun calculateParameterCountOfCopyFunction(copyFunction: Method): Int {
    // The copy function always has the first parameter as the object to copy from,
    // and the last parameter as the ignored marker parameter.
    // So we know to ignore those two parameters.
    val baseParamCount = copyFunction.parameterTypes.size - 2

    // A bitmask parameter is added for every 32 normal parameters.
    val bitMaskCount = ceil(baseParamCount / 33.0).toInt()
    return baseParamCount - bitMaskCount
}

private val Class<*>.defaultParameterValue: Any?
    get() = when (this) {
        Integer.TYPE -> 0
        java.lang.Boolean.TYPE -> false
        java.lang.Float.TYPE -> 0f
        Character.TYPE -> 'A'
        java.lang.Byte.TYPE -> Byte.MIN_VALUE
        java.lang.Short.TYPE -> Short.MIN_VALUE
        java.lang.Long.TYPE -> 0L
        java.lang.Double.TYPE -> 0.0
        else -> null
    }

/**
 * Gets a property value from a data class using Java reflection.
 *
 * Tries in order:
 * 1. Getter method (getXxx or isXxx for booleans)
 * 2. Direct field access
 *
 * This avoids using KClass.memberProperties which requires Kotlin reflection metadata.
 */
@InternalMavericksApi
fun getPropertyValue(any: Any, propertyName: String): Any? {
    val clazz = any::class.java

    // Try getter method: getXxx or isXxx (for booleans)
    val capitalizedName = propertyName.replaceFirstChar { it.uppercaseChar() }
    val getter = clazz.declaredMethods.find {
        (it.name == "get$capitalizedName" || it.name == "is$capitalizedName") &&
            it.parameterCount == 0
    }
    if (getter != null) {
        getter.isAccessible = true
        return getter.invoke(any)
    }

    // Try direct field access
    return try {
        val field = clazz.getDeclaredField(propertyName)
        field.isAccessible = true
        field.get(any)
    } catch (e: NoSuchFieldException) {
        error("Could not find property '$propertyName' on ${clazz.simpleName}")
    }
}
