package com.airbnb.mvrx

import java.lang.reflect.Method
import java.lang.reflect.Modifier
import kotlin.math.ceil

/**
 * Java reflection utilities for working with Kotlin data classes.
 *
 * These utilities avoid using Kotlin reflection APIs that read metadata (like KClass.isData,
 * KClass.memberProperties, KFunction.callBy) because they can fail in environments with
 * incompatible kotlin-reflect versions.
 */

/**
 * Since we can only use java reflection, this basically duck types a data class.
 * componentN methods are also used for @PersistState.
 *
 * This avoids using KClass.isData which requires reading Kotlin metadata and can fail
 * in environments with incompatible kotlin-reflect versions (e.g., Android Studio's
 * layoutlib with Kotlin 2.3+).
 */
@InternalMavericksApi
val Class<*>.isData: Boolean
    get() {
        // When a value class is present in the constructor, Kotlin mangles the copy method name
        // to avoid signature clashes (e.g., "copy-KtkBMb8$default" instead of "copy$default").
        // We check for either the exact name "copy$default" or the pattern "copy-*$default".
        val hasCopyDefault = declaredMethods.any { method ->
            method.isSynthetic && method.name.let { name ->
                name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
            }
        }
        if (!hasCopyDefault) return false

        // Similarly, component1 can be mangled when it's a value class type.
        // It can also have module names appended for internal properties.
        // Patterns: "component1", "component1$module", "component1-<hash>"
        val hasComponent1 = declaredMethods.any { method ->
            method.name.let { name ->
                name == "component1" ||
                    name.startsWith("component1\$") ||
                    name.startsWith("component1-")
            }
        }
        if (!hasComponent1) return false

        declaredMethods.firstOrNull { it.name == "equals" } ?: return false
        declaredMethods.firstOrNull { it.name == "hashCode" } ?: return false
        return true
    }

/**
 * Calls the copy() method on a Kotlin data class instance using Java reflection.
 *
 * This uses the synthetic copy$default method generated by the Kotlin compiler,
 * which handles default parameter values. This avoids using KFunction.callBy()
 * which requires Kotlin reflection metadata and can fail in environments with
 * incompatible kotlin-reflect versions.
 *
 * @param params Map of parameter names to their new values. Parameters not
 *               specified will retain their current values from this instance.
 * @return A new instance with the specified parameters changed.
 */
@InternalMavericksApi
@Suppress("UNCHECKED_CAST")
fun <T : Any> T.callCopy(vararg params: Pair<String, Any?>): T {
    val jvmClass = this::class.java
    val paramMap = params.toMap()

    // Find copy$default - the synthetic method that handles default parameters
    // When a value class is present, the method name may be mangled (e.g., "copy-KtkBMb8$default")
    val copyFunction = jvmClass.declaredMethods.first { method ->
        method.isSynthetic && method.name.let { name ->
            name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
        }
    }

    // For data classes, Kotlin generates a static function called copy$default.
    // The first parameter is the object to copy from.
    // The next parameters are all of parameters to copy (it's jvm bytecode/java so there are no optional parameters in the generated method).
    // The next parameter(s) are a bitmask. Each parameter index corresponds to one bit in the int.
    //     If the bitmask is 1 for a given parameter then the new object will have the original object's value and the parameter value will be ignored.
    //     If the bitmask is 0 then it will use the value from the parameter.
    //     There is 1 bitmask for every 32 parameters. If there are 48 parameters, there will be 2 bitmasks. Parameter 33 will be the first bit of the 2nd bitmask.
    // The last parameter is ignored. It can be null.

    // We need to know how many parameters go to the copy function in order to invoke it.
    // Note that this is not the same as the number of parameters in the constructor.
    // The constructor can contain a "DefaultConstructorMarker" in some cases, such as if a value class type is present in the constructor,
    // and in this case the number of parameters of the constructor is greater than the number of parameters in the copy function.
    // For accuracy in all cases we use the copy function to determine the number of parameters.
    val paramCount = calculateParameterCountOfCopyFunction(copyFunction)

    // Build a mapping from property names to constructor parameter indices.
    // We use componentN methods to determine the correct order, since declaredFields
    // order is not guaranteed by the JVM and can be changed by R8/ProGuard.
    val propertyIndexMap = buildPropertyIndexMap(jvmClass, this)

    // There is 1 bitmask for each block of 32 parameters.
    val parameterBitMasks = IntArray(ceil(paramCount / 32.0).toInt())
    val parameters = arrayOfNulls<Any?>(paramCount)

    // Initialize all parameters to use default values (bitmask = 1 means use original value)
    for (i in 0 until paramCount) {
        parameterBitMasks[i / 32] = parameterBitMasks[i / 32] or (1 shl (i % 32))
        // These parameters will be ignored. We just need to put in something of the correct type to match the method signature.
        // 1 is added to account for the first parameter, which is the object to copy from (ie, the original instance).
        parameters[i] = copyFunction.parameterTypes[i + 1].defaultParameterValue
    }

    // Set the parameters we want to change
    for ((propName, newValue) in paramMap) {
        val index = propertyIndexMap[propName]
            ?: error("Could not find constructor parameter index for property '$propName' on ${jvmClass.simpleName}")
        parameters[index] = newValue
        // Clear the bitmask for this parameter so the new value is used instead of the original
        parameterBitMasks[index / 32] = parameterBitMasks[index / 32] and (1 shl (index % 32)).inv()
    }

    // See the comment above for information on the parameters here.
    copyFunction.isAccessible = true
    return copyFunction.invoke(
        null, // Indicates the object to invoke on. This is null for a static method.
        this,
        *parameters,
        *parameterBitMasks.toTypedArray(),
        null
    ) as T
}

/**
 * Builds a mapping from property names to their constructor parameter index.
 *
 * This uses componentN methods (component1, component2, etc.) which are generated by Kotlin
 * for data classes and preserve the constructor parameter order. This is more reliable than
 * using declaredFields, whose order is not guaranteed by the JVM and can be changed by
 * R8/ProGuard optimization.
 *
 * The mapping is built by iterating through componentN methods and finding the field that
 * matches each component's value. This ensures only constructor parameters are mapped
 * (since body properties don't have componentN methods), avoiding issues where a body
 * property with the same type and value as a constructor parameter could incorrectly
 * "steal" a component slot.
 */
private fun <T : Any> buildPropertyIndexMap(jvmClass: Class<*>, instance: T): Map<String, Int> {
    // componentN methods are named component1, component2, etc.
    // N corresponds to constructor parameter position (1-indexed)
    // Names may have suffixes like "component1-abc" for value classes or "component1$module" for internal
    val componentRegex = Regex("""component(\d+).*""")
    val componentMethods = jvmClass.declaredMethods
        .mapNotNull { method ->
            if (method.parameterCount != 0) return@mapNotNull null
            val match = componentRegex.matchEntire(method.name) ?: return@mapNotNull null
            val n = match.groupValues[1].toIntOrNull() ?: return@mapNotNull null
            n to method
        }
        .sortedBy { it.first }

    // Get all instance fields
    val fields = jvmClass.declaredFields
        .filter { !Modifier.isStatic(it.modifiers) && !it.isSynthetic }

    val result = mutableMapOf<String, Int>()
    val usedFields = mutableSetOf<String>()

    // For each componentN method, find the field that matches its value.
    // This ensures we only map constructor parameters (which have componentN methods)
    // and not body properties (which don't have componentN methods).
    for ((n, componentMethod) in componentMethods) {
        val index = n - 1 // componentN is 1-indexed, parameters are 0-indexed
        componentMethod.isAccessible = true
        val componentValue = componentMethod.invoke(instance)

        for (field in fields) {
            if (field.name in usedFields) continue

            // Type must match to avoid ambiguity with same-value fields of different types
            if (field.type != componentMethod.returnType) continue

            field.isAccessible = true
            val fieldValue = field.get(instance)

            if (fieldValue == componentValue) {
                result[field.name] = index
                usedFields.add(field.name)
                break
            }
        }
    }

    return result
}

/**
 * Calculates the number of data class properties from the copy$default function.
 * This is more accurate than counting constructor parameters because value classes
 * can cause additional synthetic parameters in the constructor.
 */
@InternalMavericksApi
fun calculateParameterCountOfCopyFunction(copyFunction: Method): Int {
    // The copy function always has the first parameter as the object to copy from,
    // and the last parameter as the ignored marker parameter.
    // So we know to ignore those two parameters.
    val baseParamCount = copyFunction.parameterTypes.size - 2

    // A bitmask parameter is added for every 32 normal parameters.
    val bitMaskCount = ceil(baseParamCount / 33.0).toInt()
    return baseParamCount - bitMaskCount
}

private val Class<*>.defaultParameterValue: Any?
    get() = when (this) {
        Integer.TYPE -> 0
        java.lang.Boolean.TYPE -> false
        java.lang.Float.TYPE -> 0f
        Character.TYPE -> 'A'
        java.lang.Byte.TYPE -> Byte.MIN_VALUE
        java.lang.Short.TYPE -> Short.MIN_VALUE
        java.lang.Long.TYPE -> 0L
        java.lang.Double.TYPE -> 0.0
        else -> null
    }

/**
 * Gets a property value from a data class using Java reflection.
 *
 * Tries in order:
 * 1. Getter method (getXxx or isXxx for booleans)
 * 2. Direct field access
 *
 * This avoids using KClass.memberProperties which requires Kotlin reflection metadata.
 */
@InternalMavericksApi
fun Any.getPropertyValue(propertyName: String): Any? {
    val clazz = this::class.java

    // Try getter method: getXxx or isXxx (for booleans)
    val capitalizedName = propertyName.replaceFirstChar { it.uppercaseChar() }
    val getter = clazz.declaredMethods.find {
        (it.name == "get$capitalizedName" || it.name == "is$capitalizedName") &&
            it.parameterCount == 0
    }
    if (getter != null) {
        getter.isAccessible = true
        return getter.invoke(this)
    }

    // Try direct field access
    return try {
        val field = clazz.getDeclaredField(propertyName)
        field.isAccessible = true
        field.get(this)
    } catch (e: NoSuchFieldException) {
        error("Could not find property '$propertyName' on ${clazz.simpleName}")
    }
}
