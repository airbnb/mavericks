package com.airbnb.mvrx

import java.lang.reflect.Method
import java.lang.reflect.Modifier
import kotlin.math.ceil

/**
 * Java reflection utilities for working with Kotlin data classes.
 *
 * These utilities avoid using Kotlin reflection APIs that read metadata (like KClass.isData,
 * KClass.memberProperties, KFunction.callBy) because they can fail in environments with
 * incompatible kotlin-reflect versions.
 */

/**
 * Since we can only use java reflection, this basically duck types a data class.
 * componentN methods are also used for @PersistState.
 *
 * This avoids using KClass.isData which requires reading Kotlin metadata and can fail
 * in environments with incompatible kotlin-reflect versions (e.g., Android Studio's
 * layoutlib with Kotlin 2.3+).
 */
@InternalMavericksApi
val Class<*>.isData: Boolean
    get() {
        // When a value class is present in the constructor, Kotlin mangles the copy method name
        // to avoid signature clashes (e.g., "copy-KtkBMb8$default" instead of "copy$default").
        // We check for either the exact name "copy$default" or the pattern "copy-*$default".
        val hasCopyDefault = declaredMethods.any { method ->
            method.isSynthetic && method.name.let { name ->
                name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
            }
        }
        if (!hasCopyDefault) return false

        // Similarly, component1 can be mangled when it's a value class type.
        // It can also have module names appended for internal properties.
        // Patterns: "component1", "component1$module", "component1-<hash>"
        val hasComponent1 = declaredMethods.any { method ->
            method.name.let { name ->
                name == "component1" ||
                    name.startsWith("component1\$") ||
                    name.startsWith("component1-")
            }
        }
        if (!hasComponent1) return false

        declaredMethods.firstOrNull { it.name == "equals" } ?: return false
        declaredMethods.firstOrNull { it.name == "hashCode" } ?: return false
        return true
    }

/**
 * Calls the copy() method on a Kotlin data class instance using Java reflection.
 *
 * This uses the synthetic copy$default method generated by the Kotlin compiler,
 * which handles default parameter values. This avoids using KFunction.callBy()
 * which requires Kotlin reflection metadata and can fail in environments with
 * incompatible kotlin-reflect versions.
 *
 * @param params Map of parameter names to their new values. Parameters not
 *               specified will retain their current values from this instance.
 * @return A new instance with the specified parameters changed.
 */
@InternalMavericksApi
@Suppress("UNCHECKED_CAST")
fun <T : Any> T.callCopy(vararg params: Pair<String, Any?>): T {
    val jvmClass = this::class.java
    val paramMap = params.toMap()

    // Get field names in order - these match the constructor parameter order
    val fieldNames = jvmClass.declaredFields
        .filter { !Modifier.isStatic(it.modifiers) && !it.isSynthetic }
        .map { it.name }

    // Find copy$default - the synthetic method that handles default parameters
    // When a value class is present, the method name may be mangled (e.g., "copy-KtkBMb8$default")
    val copyFunction = jvmClass.declaredMethods.first { method ->
        method.isSynthetic && method.name.let { name ->
            name == "copy\$default" || (name.startsWith("copy-") && name.endsWith("\$default"))
        }
    }

    // For data classes, Kotlin generates a static function called copy$default.
    // The first parameter is the object to copy from.
    // The next parameters are all of parameters to copy (it's jvm bytecode/java so there are no optional parameters in the generated method).
    // The next parameter(s) are a bitmask. Each parameter index corresponds to one bit in the int.
    //     If the bitmask is 1 for a given parameter then the new object will have the original object's value and the parameter value will be ignored.
    //     If the bitmask is 0 then it will use the value from the parameter.
    //     There is 1 bitmask for every 32 parameters. If there are 48 parameters, there will be 2 bitmasks. Parameter 33 will be the first bit of the 2nd bitmask.
    // The last parameter is ignored. It can be null.

    // We need to know how many parameters go to the copy function in order to invoke it.
    // Note that this is not the same as the number of parameters in the constructor.
    // The constructor can contain a "DefaultConstructorMarker" in some cases, such as if a value class type is present in the constructor,
    // and in this case the number of parameters of the constructor is greater than the number of parameters in the copy function.
    // For accuracy in all cases we use the copy function to determine the number of parameters.
    val paramCount = calculateParameterCountOfCopyFunction(copyFunction)

    // There is 1 bitmask for each block of 32 parameters.
    val parameterBitMasks = IntArray(ceil(paramCount / 32.0).toInt())
    val parameters = arrayOfNulls<Any?>(paramCount)

    for (i in 0 until paramCount) {
        val fieldName = fieldNames.getOrNull(i)
        if (fieldName != null && paramMap.containsKey(fieldName)) {
            // Copy the new value into the parameter array.
            // The bitmask for this element will be 0 so this value will be copied to the new object.
            parameters[i] = paramMap[fieldName]
            continue
        }

        // Set the bitmask for this parameter to 1 so it copies the value from the original object.
        parameterBitMasks[i / 32] = parameterBitMasks[i / 32] or (1 shl (i % 32))
        // These parameters will be ignored. We just need to put in something of the correct type to match the method signature.
        // 1 is added to account for the first parameter, which is the object to copy from (ie, the original instance).
        parameters[i] = copyFunction.parameterTypes[i + 1].defaultParameterValue
    }

    // See the comment above for information on the parameters here.
    copyFunction.isAccessible = true
    return copyFunction.invoke(
        null, // Indicates the object to invoke on. This is null for a static method.
        this,
        *parameters,
        *parameterBitMasks.toTypedArray(),
        null
    ) as T
}

/**
 * Calculates the number of data class properties from the copy$default function.
 * This is more accurate than counting constructor parameters because value classes
 * can cause additional synthetic parameters in the constructor.
 */
@InternalMavericksApi
fun calculateParameterCountOfCopyFunction(copyFunction: Method): Int {
    // The copy function always has the first parameter as the object to copy from,
    // and the last parameter as the ignored marker parameter.
    // So we know to ignore those two parameters.
    val baseParamCount = copyFunction.parameterTypes.size - 2

    // A bitmask parameter is added for every 32 normal parameters.
    val bitMaskCount = ceil(baseParamCount / 33.0).toInt()
    return baseParamCount - bitMaskCount
}

private val Class<*>.defaultParameterValue: Any?
    get() = when (this) {
        Integer.TYPE -> 0
        java.lang.Boolean.TYPE -> false
        java.lang.Float.TYPE -> 0f
        Character.TYPE -> 'A'
        java.lang.Byte.TYPE -> Byte.MIN_VALUE
        java.lang.Short.TYPE -> Short.MIN_VALUE
        java.lang.Long.TYPE -> 0L
        java.lang.Double.TYPE -> 0.0
        else -> null
    }

/**
 * Gets a property value from a data class using Java reflection.
 *
 * Tries in order:
 * 1. Getter method (getXxx or isXxx for booleans)
 * 2. Direct field access
 *
 * This avoids using KClass.memberProperties which requires Kotlin reflection metadata.
 */
@InternalMavericksApi
fun Any.getPropertyValue(propertyName: String): Any? {
    val clazz = this::class.java

    // Try getter method: getXxx or isXxx (for booleans)
    val capitalizedName = propertyName.replaceFirstChar { it.uppercaseChar() }
    val getter = clazz.declaredMethods.find {
        (it.name == "get$capitalizedName" || it.name == "is$capitalizedName") &&
            it.parameterCount == 0
    }
    if (getter != null) {
        getter.isAccessible = true
        return getter.invoke(this)
    }

    // Try direct field access
    return try {
        val field = clazz.getDeclaredField(propertyName)
        field.isAccessible = true
        field.get(this)
    } catch (e: NoSuchFieldException) {
        error("Could not find property '$propertyName' on ${clazz.simpleName}")
    }
}
